### 1. 什么是闭包？闭包有什么缺陷？
答：闭包是函数与其引用到的外部变量的组合体。闭包可捕获外部作用域变量并在函数返回后继续使用。
- 优点：可封装状态、实现函数式编程风格。
- 缺陷：
  - 容易导致变量被意外共享（循环中捕获迭代变量）。
  - 持有外部变量会延长其生命周期，可能造成内存占用或逃逸到堆。

示例：
```go
func Counter() func() int {
    i := 0
    return func() int { i++; return i }
}
```

### 2. 什么情况下会出现栈溢出？
答：
- 无限递归或递归深度过大且每帧栈空间消耗较高；
- 非法指针操作导致的栈破坏；
- Cgo 调用未正确设置栈空间。

### 3. 什么是不定参数？可以传入多个值吗？如何使用？
答：使用 `...T` 表示变长参数，调用时可传 0 个或多个值，也可用切片通过 `slice...` 传入。
示例：
```go
func Sum(nums ...int) int { total := 0; for _, n := range nums { total += n }; return total }
_ = Sum(1,2,3)
arr := []int{1,2,3}; _ = Sum(arr...)
```

### 4. 什么是 defer？运作机制？
答：`defer` 用于在当前函数返回前执行延迟调用，按 LIFO 顺序执行。参数在声明 `defer` 时就已求值。

### 5. 一个函数里 `defer` 能超过 8 个吗？
答：可以。8 只是编译器“开放编码（open-coded defer）”优化的阈值之一，超过依然可用，只是可能回退到较慢路径。

### 6. `defer` 能修改返回值吗？如何修改？
答：可以，需使用命名返回值并在 `defer` 中修改。
```go
func f() (x int) {
    defer func(){ x += 1 }()
    return 1 // 最终返回 2
}
```

### 7. 数组和切片的区别？
答：
- 数组：值类型，长度是类型的一部分，拷贝会复制全部元素。
- 切片：引用描述符（指针、长度、容量），底层指向数组，拷贝时仅复制描述符，引用相同底层数据。

### 8. 切片怎么扩容的？
答：当 `append` 超出容量时，运行时会：
- 分配更大的底层数组（增长因子与实现相关，较小时约 2 倍，较大时更保守）；
- 将旧数据拷贝到新数组；
- 返回指向新数组的切片。

---
### defer 的内部实现（补充）
- 堆上分配：defer 记录在堆上，需 GC 管理，开销较大。
- 栈上分配：记录在 goroutine 栈上，比堆上更高效（约 30%）。
- 开放编码（Open-Coded Defer）：编译期内联优化，等价于将逻辑展开在函数末尾执行。

触发开放编码的典型条件（简化记忆）：
- 单函数内 `defer` 数量较少（常见阈值 ≤ 8）；
- `defer` 不在循环中；
- `return` 与 `defer` 的组合不复杂（例如乘积 ≤ 15）。

这些阈值是实现层面的性能优化约束，不影响语义正确性。